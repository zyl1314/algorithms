## 题目描述
> 给定一个序列（至少含有 1 个数），从该序列中寻找一个连续的子序列，使得子序列的和最大。


例如，给定序列 [-2,1,-3,4,-1,2,1,-5,4]，
连续子序列 [4,-1,2,1] 的和最大，为 6。

## 示例

```

```
## 代码

```
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
    let arr = getSubArray(0, nums.length - 1, nums);
    let sum = 0;
    for (let i = 0; i < arr.length; i++) {
        sum += arr[i];
    }
    return sum;
}

function getSubArray(start, end, nums) {

   if (start == end) return [nums[start]];

    let middle = Math.floor((start + end) / 2);

    let leftMaxList = getSubArray(start, middle, nums);
    let rightMaxList = getSubArray(middle + 1, end, nums);
    
    let leftMaxListSum = 0;
    for (let i = 0; i < leftMaxList.length; i++) {
        leftMaxListSum += leftMaxList[i];
    }
    let rightMaxListSum = 0;
    for (let i = 0; i < rightMaxList.length; i++) {
        rightMaxListSum += rightMaxList[i];
    }

    let leftIndex = middle;
    let leftSum = nums[leftIndex];
    let leftMaxSum = nums[leftIndex];
    for (let i = leftIndex - 1; i >= start; i--) {
        leftSum += nums[i];
        if (leftSum > leftMaxSum) {
            leftMaxSum = leftSum;
            leftIndex = i;
        }
    }

    let rightIndex = middle + 1;
    let rightSum = nums[rightIndex];
    let rightMaxSum = nums[rightIndex];
    for (let i = rightIndex + 1; i <= end; i++) {
        rightSum += nums[i];
        if (rightSum > rightMaxSum) {
            rightMaxSum = rightSum;
            rightIndex = i;
        }
    }
    let middleMaxSum = leftMaxSum + rightMaxSum;
    // console.log(leftMaxList, rightMaxList, leftMaxSum, rightMaxSum)
    if (leftMaxListSum > rightMaxListSum) {
        if (leftMaxListSum > middleMaxSum) {
            return leftMaxList;
        } else {
            return nums.slice(leftIndex, rightIndex + 1);
        }
    } else {
        if (rightMaxListSum > middleMaxSum) {
            return rightMaxList;
        } else {
            return nums.slice(leftIndex, rightIndex + 1);
        }
    }
}
```

## 思考

使用的分治的解法

学习了动态规划后再给出简单解法